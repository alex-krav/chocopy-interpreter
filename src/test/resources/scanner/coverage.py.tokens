ID count
COLON :
INT_TYPE
EQUAL =
NUMBER 0
NEWLINE
DEF
ID foo
LEFT_PAREN (
ID s
COLON :
STR_TYPE
RIGHT_PAREN )
ARROW ->
INT_TYPE
COLON :
NEWLINE
INDENT
RETURN
LEN_NATIVE_FUN
LEFT_PAREN (
ID s
RIGHT_PAREN )
NEWLINE
DEDENT
CLASS
ID bar
LEFT_PAREN (
OBJECT_TYPE
RIGHT_PAREN )
COLON :
NEWLINE
INDENT
ID p
COLON :
BOOL_TYPE
EQUAL =
TRUE
NEWLINE
DEF
ID baz
LEFT_PAREN (
SELF
COLON :
IDSTRING "bar"
COMMA ,
ID xx
COLON :
LEFT_BRACKET [
INT_TYPE
RIGHT_BRACKET ]
RIGHT_PAREN )
ARROW ->
STR_TYPE
COLON :
NEWLINE
INDENT
GLOBAL
ID count
NEWLINE
ID x
COLON :
INT_TYPE
EQUAL =
NUMBER 0
NEWLINE
ID y
COLON :
INT_TYPE
EQUAL =
NUMBER 1
NEWLINE
DEF
ID qux
LEFT_PAREN (
ID y
COLON :
INT_TYPE
RIGHT_PAREN )
ARROW ->
OBJECT_TYPE
COLON :
NEWLINE
INDENT
NONLOCAL
ID x
NEWLINE
IF
ID x
GREATER >
ID y
COLON :
NEWLINE
INDENT
ID x
EQUAL =
MINUS -
NUMBER 1
NEWLINE
DEDENT
DEDENT
FOR
ID x
IN
ID xx
COLON :
NEWLINE
INDENT
SELF
DOT .
ID p
EQUAL =
ID x
EQUAL_EQUAL ==
NUMBER 2
NEWLINE
DEDENT
ID qux
LEFT_PAREN (
NUMBER 0
RIGHT_PAREN )
NEWLINE
ID count
EQUAL =
ID count
PLUS +
NUMBER 1
NEWLINE
WHILE
ID x
LESS_EQUAL <=
NUMBER 0
COLON :
NEWLINE
INDENT
IF
SELF
DOT .
ID p
COLON :
NEWLINE
INDENT
ID xx
LEFT_BRACKET [
NUMBER 0
RIGHT_BRACKET ]
EQUAL =
ID xx
LEFT_BRACKET [
NUMBER 1
RIGHT_BRACKET ]
NEWLINE
SELF
DOT .
ID p
EQUAL =
NOT
SELF
DOT .
ID p
NEWLINE
ID x
EQUAL =
ID x
PLUS +
NUMBER 1
NEWLINE
DEDENT
ELIF
ID foo
LEFT_PAREN (
IDSTRING "Long"
LEFT_BRACKET [
NUMBER 0
RIGHT_BRACKET ]
RIGHT_PAREN )
EQUAL_EQUAL ==
NUMBER 1
COLON :
NEWLINE
INDENT
RETURN
SELF
IS
NONE
NEWLINE
DEDENT
DEDENT
RETURN
IDSTRING "Nope"
NEWLINE
DEDENT
DEDENT
PRINT_NATIVE_FUN
LEFT_PAREN (
ID bar
LEFT_PAREN (
RIGHT_PAREN )
DOT .
ID baz
LEFT_PAREN (
LEFT_BRACKET [
NUMBER 1
COMMA ,
NUMBER 2
RIGHT_BRACKET ]
RIGHT_PAREN )
RIGHT_PAREN )
NEWLINE
EOF
